<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fleet Map - Abstract View</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&family=Space+Grotesk:wght@300;400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --bg-dark: #0a0e14;
            --bg-card: #12171f;
            --bg-hover: #1a212d;
            --accent-green: #00ff88;
            --accent-blue: #00d4ff;
            --accent-orange: #ff9500;
            --accent-red: #ff4444;
            --accent-purple: #a855f7;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --border-color: #21262d;
        }
        
        body {
            font-family: 'Space Grotesk', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .header h1 {
            font-size: 1.8rem;
            font-weight: 600;
            background: linear-gradient(135deg, var(--accent-green), var(--accent-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        .status-dot.connected { background: var(--accent-green); }
        .status-dot.disconnected { background: var(--accent-red); }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .stats-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }
        
        .stat-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
        }
        
        .stat-card .value {
            font-size: 2rem;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .stat-card .label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 4px;
        }
        
        .stat-card.agents .value { color: var(--accent-blue); }
        .stat-card.tasks .value { color: var(--accent-orange); }
        .stat-card.triggers .value { color: var(--accent-green); }
        .stat-card.urgent .value { color: var(--accent-red); }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
        }
        
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .panel {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            overflow: hidden;
        }
        
        .panel-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .panel-header h2 {
            font-size: 1.1rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .panel-header h2::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 2px;
        }
        
        .panel.agents .panel-header h2::before { background: var(--accent-blue); }
        .panel.tasks .panel-header h2::before { background: var(--accent-orange); }
        .panel.triggers .panel-header h2::before { background: var(--accent-green); }
        .panel.log .panel-header h2::before { background: var(--accent-purple); }
        
        .panel-content {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .agent-item, .task-item, .trigger-item {
            padding: 12px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }
        
        .agent-item:hover, .task-item:hover, .trigger-item:hover {
            background: var(--bg-hover);
        }
        
        .agent-item:last-child, .task-item:last-child, .trigger-item:last-child {
            border-bottom: none;
        }
        
        .agent-info, .task-info, .trigger-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .agent-name, .task-name, .trigger-name {
            font-weight: 500;
            font-size: 0.95rem;
        }
        
        .agent-meta, .task-meta, .trigger-meta {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
        }
        
        .status-badge {
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
        }
        
        .status-badge.idle { background: rgba(0, 255, 136, 0.15); color: var(--accent-green); }
        .status-badge.busy { background: rgba(0, 212, 255, 0.15); color: var(--accent-blue); }
        .status-badge.at_capacity { background: rgba(255, 149, 0, 0.15); color: var(--accent-orange); }
        .status-badge.offline { background: rgba(255, 68, 68, 0.15); color: var(--accent-red); }
        .status-badge.urgent { background: rgba(255, 68, 68, 0.15); color: var(--accent-red); }
        .status-badge.eligible { background: rgba(0, 255, 136, 0.15); color: var(--accent-green); }
        .status-badge.ineligible { background: rgba(255, 68, 68, 0.15); color: var(--accent-red); }
        
        .distance-badge {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--accent-green);
        }
        
        .log-panel {
            grid-column: 1 / -1;
        }
        
        .log-content {
            max-height: 200px;
            overflow-y: auto;
            padding: 12px 20px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
        }
        
        .log-entry {
            padding: 4px 0;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 12px;
        }
        
        .log-entry:last-child {
            border-bottom: none;
        }
        
        .log-time {
            color: var(--text-secondary);
            flex-shrink: 0;
        }
        
        .log-message {
            word-break: break-word;
        }
        
        .log-entry.trigger .log-message { color: var(--accent-green); }
        .log-entry.location .log-message { color: var(--accent-blue); }
        .log-entry.task .log-message { color: var(--accent-orange); }
        .log-entry.error .log-message { color: var(--accent-red); }
        
        .config-panel {
            margin-top: 24px;
            padding: 20px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
        }
        
        .config-panel h3 {
            margin-bottom: 16px;
            font-size: 1rem;
            font-weight: 500;
        }
        
        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
        }
        
        .config-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .config-item label {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        .config-item input {
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 12px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
        }
        
        .config-item input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-family: 'Space Grotesk', sans-serif;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: var(--accent-blue);
            color: var(--bg-dark);
        }
        
        .btn-primary:hover {
            background: var(--accent-green);
        }
        
        .empty-state {
            padding: 40px;
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        .empty-state.warning {
            color: var(--accent-orange);
            background: rgba(255, 149, 0, 0.1);
            border: 1px dashed var(--accent-orange);
            border-radius: 8px;
        }
        
        .refresh-indicator {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üó∫Ô∏è Fleet Abstract Map</h1>
        <div class="connection-status">
            <span class="status-dot" id="statusDot"></span>
            <span id="connectionText">Connecting...</span>
            <span class="refresh-indicator" id="lastRefresh"></span>
            <button class="btn btn-primary" onclick="requestSync()" title="Request full state sync from main dashboard">üîÑ Request Sync</button>
        </div>
    </div>
    
    <div class="stats-bar">
        <div class="stat-card agents">
            <div class="value" id="agentCount">-</div>
            <div class="label">Online Agents</div>
        </div>
        <div class="stat-card tasks">
            <div class="value" id="taskCount">-</div>
            <div class="label">Unassigned Tasks</div>
        </div>
        <div class="stat-card triggers">
            <div class="value" id="triggerCount">-</div>
            <div class="label">Proximity Triggers</div>
        </div>
        <div class="stat-card urgent">
            <div class="value" id="urgentCount">-</div>
            <div class="label">Urgent Tasks</div>
        </div>
    </div>
    
    <div class="main-content">
        <div class="panel agents">
            <div class="panel-header">
                <h2>Agents</h2>
                <span class="refresh-indicator" id="agentRefresh"></span>
            </div>
            <div class="panel-content" id="agentList">
                <div class="empty-state">No agents in fleet state</div>
            </div>
        </div>
        
        <div class="panel tasks">
            <div class="panel-header">
                <h2>Unassigned Tasks</h2>
                <span class="refresh-indicator" id="taskRefresh"></span>
            </div>
            <div class="panel-content" id="taskList">
                <div class="empty-state">No unassigned tasks</div>
            </div>
        </div>
        
        <div class="panel triggers">
            <div class="panel-header">
                <h2>Proximity Triggers</h2>
                <span class="refresh-indicator" id="triggerRefresh"></span>
            </div>
            <div class="panel-content" id="triggerList">
                <div class="empty-state">No agents near tasks</div>
            </div>
        </div>
        
        <div class="panel log log-panel">
            <div class="panel-header">
                <h2>Activity Log</h2>
                <button class="btn btn-primary" onclick="clearLog()">Clear</button>
            </div>
            <div class="log-content" id="logContent">
                <div class="log-entry">
                    <span class="log-time">--:--:--</span>
                    <span class="log-message">Waiting for events...</span>
                </div>
            </div>
        </div>
    </div>
    
    <div class="config-panel">
        <h3>‚öôÔ∏è Configuration</h3>
        <div class="config-grid">
            <div class="config-item">
                <label>Max Distance (km)</label>
                <input type="number" id="maxDistance" step="0.5" value="3.0" title="Max distance for agent-task compatibility AND assignment trigger">
            </div>
            <div class="config-item">
                <label>Chain Lookahead (km)</label>
                <input type="number" id="chainRadius" step="0.5" value="5.0" title="Distance to look ahead for chaining opportunities">
            </div>
            <div class="config-item">
                <label>Cooldown (s)</label>
                <input type="number" id="cooldown" step="5" value="30" title="Time between re-optimizations for same agent">
            </div>
            <div class="config-item" style="justify-content: flex-end;">
                <button class="btn btn-primary" onclick="updateConfig()">Update Config</button>
            </div>
        </div>
    </div>
    
    <script>
        // WebSocket connection with auto-reconnect
        const socket = io(window.location.origin, {
            transports: ['websocket', 'polling'],
            reconnection: true,
            reconnectionAttempts: Infinity,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000
        });
        
        let logEntries = [];
        const MAX_LOG_ENTRIES = 50;
        let lastDataReceived = Date.now();
        let staleDataWarningShown = false;
        
        // Connection events
        socket.on('connect', () => {
            document.getElementById('statusDot').className = 'status-dot connected';
            document.getElementById('connectionText').textContent = 'Connected';
            addLog('system', 'Connected to OR-Tools server');
            staleDataWarningShown = false;
            refreshData();
        });
        
        socket.on('disconnect', () => {
            document.getElementById('statusDot').className = 'status-dot disconnected';
            document.getElementById('connectionText').textContent = 'Disconnected - Reconnecting...';
            addLog('error', 'Disconnected from server - attempting to reconnect');
        });
        
        socket.on('reconnect', (attemptNumber) => {
            addLog('system', `Reconnected after ${attemptNumber} attempts`);
            refreshData();
        });
        
        socket.on('reconnect_attempt', (attemptNumber) => {
            document.getElementById('connectionText').textContent = `Reconnecting... (${attemptNumber})`;
        });
        
        // Request sync from main dashboard (emits event that main dashboard listens for)
        function requestSync() {
            addLog('system', 'üîÑ Requesting sync from main dashboard...');
            socket.emit('debug:request_sync', { 
                source: 'fleet_map',
                timestamp: new Date().toISOString()
            });
            // Also try to refresh local data
            refreshData();
        }
        
        // Check for stale data (no events in 5 minutes - longer threshold for event-driven system)
        setInterval(() => {
            const timeSinceLastUpdate = Date.now() - lastDataReceived;
            if (timeSinceLastUpdate > 300000 && !staleDataWarningShown) {  // 5 minutes
                addLog('warning', '‚ö†Ô∏è No events received for 5+ minutes - connection may be broken');
                staleDataWarningShown = true;
            }
        }, 30000);
        
        // Listen for fleet events
        socket.on('fleet:routes_updated', (data) => {
            lastDataReceived = Date.now();
            staleDataWarningShown = false;
            addLog('task', `Fleet optimized: ${data.metadata?.tasks_assigned || 0} tasks assigned (${data.trigger_event || 'manual'})`);
            refreshData();
        });
        
        socket.on('task:assignment_suggested', (data) => {
            lastDataReceived = Date.now();
            addLog('trigger', `üéØ Assignment suggested: ${data.agent_name} ‚Üí ${data.task_restaurant} (${data.distance_km}km)`);
            refreshData();
        });
        
        socket.on('agent:location_update_ack', (data) => {
            lastDataReceived = Date.now();
            addLog('location', `üìç Location: ${data.agent_id} ‚Üí [${data.location?.join(', ') || '?'}]`);
        });
        
        // Listen for state updates (from fleet:sync or other sources)
        socket.on('fleet:state_updated', (data) => {
            lastDataReceived = Date.now();
            staleDataWarningShown = false;
            addLog('system', `üîÑ State updated: ${data.agents || 0} agents, ${data.unassigned_tasks || 0} tasks`);
            refreshData();
        });
        
        // Agent status changed (online/offline) - update UI immediately
        socket.on('agent:status_changed', (data) => {
            lastDataReceived = Date.now();
            staleDataWarningShown = false;
            const agentId = data.agent_id;
            const status = data.status;
            const name = data.name || 'Unknown';
            
            if (status === 'offline') {
                // Remove agent from local data
                if (fleetData.agents) {
                    fleetData.agents = fleetData.agents.filter(a => String(a.id) !== String(agentId));
                }
                addLog('warning', `üî¥ Agent offline: ${name}`);
            } else if (status === 'online') {
                // Add/update agent
                if (!fleetData.agents) fleetData.agents = [];
                const existingIdx = fleetData.agents.findIndex(a => String(a.id) === String(agentId));
                const newAgent = {
                    id: agentId,
                    name: name,
                    location: data.location,
                    max_capacity: data.max_capacity || 2,
                    current_tasks: data.current_tasks || 0,
                    tags: data.tags || [],
                    priority: data.priority,
                    is_online: true
                };
                if (existingIdx >= 0) {
                    fleetData.agents[existingIdx] = newAgent;
                } else {
                    fleetData.agents.push(newAgent);
                }
                addLog('success', `üü¢ Agent online: ${name}${data.priority ? ' ‚≠ê' : ''}`);
            }
            
            updateAgentsList();  // Refresh the agent list display
            updateMap();  // Update map markers
        });
        
        // Listen for sync acknowledgment
        socket.on('fleet:sync_ack', (data) => {
            lastDataReceived = Date.now();
            staleDataWarningShown = false;
            if (data.success) {
                addLog('system', `‚úÖ Sync complete: ${data.synced?.agents || 0} agents, ${data.synced?.unassigned_tasks || 0} tasks`);
            } else {
                addLog('error', `‚ùå Sync failed: ${data.error}`);
            }
            refreshData();
        });
        
        // Task events
        socket.on('task:created', (data) => {
            lastDataReceived = Date.now();
            addLog('task', `üìã New task: ${data.task?.restaurant_name || data.restaurant_name || 'Unknown'}`);
            refreshData();
        });
        
        socket.on('task:assigned', (data) => {
            lastDataReceived = Date.now();
            addLog('task', `‚úÖ Assigned: ${data.agent_name} ‚Üí ${data.task_name || data.id?.substring(0,15) + '...'}`);
            refreshData();
        });
        
        socket.on('task:completed', (data) => {
            lastDataReceived = Date.now();
            addLog('task', `üèÅ Completed by ${data.agent_name}`);
            refreshData();
        });
        
        // Data refresh functions
        async function refreshData() {
            await Promise.all([
                refreshAgents(),
                refreshTasks(),
                refreshTriggers(),
                refreshConfig(),
                refreshHealth()
            ]);
            document.getElementById('lastRefresh').textContent = `Last: ${new Date().toLocaleTimeString()}`;
            
            // Check if state is empty and warn user
            const agentCount = parseInt(document.getElementById('agentCount').textContent) || 0;
            const taskCount = parseInt(document.getElementById('taskCount').textContent) || 0;
            
            if (agentCount === 0 && taskCount === 0 && !staleDataWarningShown) {
                addLog('warning', '‚ö†Ô∏è Fleet state is EMPTY. Click "Request Sync" or send sync from main dashboard.');
                staleDataWarningShown = true;
            }
        }
        
        async function refreshHealth() {
            try {
                const resp = await fetch('/fleet-state/health');
                const data = await resp.json();
                
                // Show warning only if there's a real issue (event-driven, so no events for 5+ min is bad)
                if (data.warning && !staleDataWarningShown) {
                    addLog('warning', `‚ö†Ô∏è ${data.warning}`);
                    staleDataWarningShown = true;
                }
                
                // Update status based on EVENTS (not sync - system is event-driven)
                const statusDot = document.getElementById('statusDot');
                
                if (data.last_event_time) {
                    const eventAge = data.seconds_since_last_event;
                    let statusText = '';
                    
                    if (eventAge < 60) {
                        statusText = `Event: ${Math.round(eventAge)}s ago`;
                        statusDot.style.background = '';  // Reset to CSS default (green)
                    } else if (eventAge < 300) {  // Under 5 min - normal for event-driven
                        statusText = `Event: ${Math.round(eventAge / 60)}m ago`;
                        statusDot.style.background = '';  // Still OK
                    } else {  // 5+ min - might be disconnected
                        statusText = `‚ö†Ô∏è No events: ${Math.round(eventAge / 60)}m`;
                        statusDot.style.background = 'var(--accent-orange)';
                    }
                    
                    document.getElementById('lastRefresh').textContent = statusText;
                } else if (data.is_empty) {
                    document.getElementById('lastRefresh').textContent = '‚ö†Ô∏è Empty state';
                    statusDot.style.background = 'var(--accent-orange)';
                } else {
                    document.getElementById('lastRefresh').textContent = `Last: ${new Date().toLocaleTimeString()}`;
                }
            } catch (e) {
                console.error('Failed to refresh health:', e);
            }
        }
        
        async function refreshAgents() {
            try {
                const resp = await fetch('/fleet-state/agents');
                const data = await resp.json();
                
                document.getElementById('agentCount').textContent = data.online || 0;
                document.getElementById('agentRefresh').textContent = `${data.count || 0} total`;
                
                const list = document.getElementById('agentList');
                if (!data.agents || data.agents.length === 0) {
                    list.innerHTML = '<div class="empty-state warning">‚ö†Ô∏è No agents - click "Request Sync" button</div>';
                    return;
                }
                lastDataReceived = Date.now();  // We got valid data
                
                list.innerHTML = data.agents.map(agent => `
                    <div class="agent-item">
                        <div class="agent-info">
                            <span class="agent-name">${agent.name}</span>
                            <span class="agent-meta">
                                ID: ${agent.id} | 
                                Tasks: ${agent.capacity} | 
                                Loc: [${agent.current_location.lat.toFixed(4)}, ${agent.current_location.lng.toFixed(4)}]
                            </span>
                        </div>
                        <span class="status-badge ${agent.status.toLowerCase()}">${agent.status.toUpperCase()}</span>
                    </div>
                `).join('');
            } catch (e) {
                console.error('Failed to refresh agents:', e);
            }
        }
        
        async function refreshTasks() {
            try {
                const resp = await fetch('/fleet-state/tasks');
                const data = await resp.json();
                
                document.getElementById('taskCount').textContent = data.unassigned_count || 0;
                document.getElementById('urgentCount').textContent = data.urgent_count || 0;
                document.getElementById('taskRefresh').textContent = `${data.overdue_count || 0} overdue`;
                
                const list = document.getElementById('taskList');
                if (!data.tasks || data.tasks.length === 0) {
                    // Check if we also have no agents - if so, state is empty
                    const agentCount = parseInt(document.getElementById('agentCount').textContent) || 0;
                    if (agentCount === 0) {
                        list.innerHTML = '<div class="empty-state warning">‚ö†Ô∏è No data - click "Request Sync"</div>';
                    } else {
                        list.innerHTML = '<div class="empty-state">No unassigned tasks</div>';
                    }
                    return;
                }
                lastDataReceived = Date.now();  // We got valid data
                
                list.innerHTML = data.tasks.map(task => `
                    <div class="task-item">
                        <div class="task-info">
                            <span class="task-name">${task.restaurant_name} ‚Üí ${task.customer_name}</span>
                            <span class="task-meta">
                                Urgency: ${task.urgency_score.toFixed(0)} | 
                                Pickup: ${new Date(task.pickup_before).toLocaleTimeString()}
                            </span>
                        </div>
                        ${task.is_urgent ? '<span class="status-badge urgent">URGENT</span>' : ''}
                    </div>
                `).join('');
            } catch (e) {
                console.error('Failed to refresh tasks:', e);
            }
        }
        
        async function refreshTriggers() {
            try {
                const resp = await fetch('/fleet-state/proximity');
                const data = await resp.json();
                
                document.getElementById('triggerCount').textContent = data.count || 0;
                document.getElementById('triggerRefresh').textContent = `Radius: ${data.max_distance_km}km`;
                
                const list = document.getElementById('triggerList');
                if (!data.triggers || data.triggers.length === 0) {
                    list.innerHTML = '<div class="empty-state">No agents near tasks</div>';
                    return;
                }
                
                list.innerHTML = data.triggers.map(trigger => `
                    <div class="trigger-item">
                        <div class="trigger-info">
                            <span class="trigger-name">${trigger.agent_name} ‚Üí ${trigger.task_restaurant}</span>
                            <span class="trigger-meta">
                                ${trigger.trigger_type} | 
                                Urgency: ${trigger.task_urgency.toFixed(0)}
                                ${trigger.eligibility_reason ? ' | ' + trigger.eligibility_reason : ''}
                            </span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <span class="distance-badge">${trigger.distance_km}km</span>
                            <span class="status-badge ${trigger.is_eligible ? 'eligible' : 'ineligible'}">
                                ${trigger.is_eligible ? 'ELIGIBLE' : 'BLOCKED'}
                            </span>
                        </div>
                    </div>
                `).join('');
            } catch (e) {
                console.error('Failed to refresh triggers:', e);
            }
        }
        
        async function refreshConfig() {
            try {
                const resp = await fetch('/fleet-state/config');
                const data = await resp.json();
                
                document.getElementById('maxDistance').value = data.max_distance_km || 3;
                document.getElementById('chainRadius').value = data.chain_lookahead_radius_km || 5;
                document.getElementById('cooldown').value = data.optimization_cooldown_seconds || 30;
            } catch (e) {
                console.error('Failed to refresh config:', e);
            }
        }
        
        async function updateConfig() {
            try {
                const config = {
                    max_distance_km: parseFloat(document.getElementById('maxDistance').value),
                    chain_lookahead_radius_km: parseFloat(document.getElementById('chainRadius').value),
                    optimization_cooldown_seconds: parseFloat(document.getElementById('cooldown').value)
                };
                
                const resp = await fetch('/fleet-state/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });
                
                const data = await resp.json();
                addLog('system', `Config updated: max_dist=${data.max_distance_km}km, chain=${data.chain_lookahead_radius_km}km, cooldown=${data.optimization_cooldown_seconds}s`);
            } catch (e) {
                addLog('error', `Failed to update config: ${e.message}`);
            }
        }
        
        function addLog(type, message) {
            const time = new Date().toLocaleTimeString();
            logEntries.unshift({ time, type, message });
            
            if (logEntries.length > MAX_LOG_ENTRIES) {
                logEntries = logEntries.slice(0, MAX_LOG_ENTRIES);
            }
            
            renderLog();
        }
        
        function renderLog() {
            const content = document.getElementById('logContent');
            content.innerHTML = logEntries.map(entry => `
                <div class="log-entry ${entry.type}">
                    <span class="log-time">${entry.time}</span>
                    <span class="log-message">${entry.message}</span>
                </div>
            `).join('');
        }
        
        function clearLog() {
            logEntries = [];
            renderLog();
        }
        
        // Auto-refresh every 5 seconds
        setInterval(refreshData, 5000);
        
        // Initial load
        refreshData();
    </script>
</body>
</html>

