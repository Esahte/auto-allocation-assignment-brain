<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proximity Broadcast Debug</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&family=Inter:wght@400;500;600;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --border: #30363d;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-orange: #d29922;
            --accent-red: #f85149;
            --accent-purple: #a371f7;
            --accent-cyan: #39c5cf;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border);
        }
        
        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
        }
        
        .status-badge.connected { background: rgba(63, 185, 80, 0.2); color: var(--accent-green); }
        .status-badge.disconnected { background: rgba(248, 81, 73, 0.2); color: var(--accent-red); }
        .status-badge.enabled { background: rgba(88, 166, 255, 0.2); color: var(--accent-blue); }
        .status-badge.disabled { background: rgba(139, 148, 158, 0.2); color: var(--text-secondary); }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
            margin-bottom: 24px;
        }
        
        .stat-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 14px;
            text-align: center;
        }
        
        .stat-card .value {
            font-size: 1.6rem;
            font-weight: 700;
            font-family: 'IBM Plex Mono', monospace;
        }
        
        .stat-card .label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-top: 4px;
        }
        
        .stat-card.blue .value { color: var(--accent-blue); }
        .stat-card.green .value { color: var(--accent-green); }
        .stat-card.orange .value { color: var(--accent-orange); }
        .stat-card.purple .value { color: var(--accent-purple); }
        .stat-card.red .value { color: var(--accent-red); }
        .stat-card.cyan .value { color: var(--accent-cyan); }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 16px;
        }
        
        @media (max-width: 1200px) {
            .main-grid { grid-template-columns: 1fr; }
        }
        
        .panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
        }
        
        .panel-header {
            padding: 10px 14px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-tertiary);
        }
        
        .panel-header h2 {
            font-size: 0.85rem;
            font-weight: 600;
        }
        
        .panel-content {
            max-height: 320px;
            overflow-y: auto;
        }
        
        .panel-content.tall {
            max-height: 400px;
        }
        
        /* Agent Item */
        .agent-item {
            padding: 10px 14px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .agent-item:last-child { border-bottom: none; }
        
        .agent-info .agent-name {
            font-weight: 500;
            font-size: 0.9rem;
        }
        
        .agent-info .agent-details {
            font-size: 0.75rem;
            color: var(--text-secondary);
            font-family: 'IBM Plex Mono', monospace;
            margin-top: 2px;
        }
        
        .agent-status {
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
        }
        
        .agent-status.idle { background: rgba(63, 185, 80, 0.2); color: var(--accent-green); }
        .agent-status.busy { background: rgba(88, 166, 255, 0.2); color: var(--accent-blue); }
        .agent-status.at-capacity { background: rgba(210, 153, 34, 0.2); color: var(--accent-orange); }
        
        /* Task Item */
        .task-item {
            padding: 10px 14px;
            border-bottom: 1px solid var(--border);
        }
        
        .task-item:last-child { border-bottom: none; }
        
        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .task-name {
            font-weight: 500;
            font-size: 0.9rem;
        }
        
        .task-details {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 4px;
        }
        
        .task-badge {
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
        }
        
        .task-badge.broadcasting { background: rgba(163, 113, 247, 0.2); color: var(--accent-purple); }
        .task-badge.waiting { background: rgba(139, 148, 158, 0.2); color: var(--text-secondary); }
        .task-badge.urgent { background: rgba(248, 81, 73, 0.2); color: var(--accent-red); }
        .task-badge.premium { background: rgba(210, 153, 34, 0.2); color: var(--accent-orange); }
        .task-badge.no-agents { background: rgba(57, 197, 207, 0.2); color: var(--accent-cyan); }
        .task-badge.declined { background: rgba(248, 81, 73, 0.3); color: var(--accent-red); }
        
        /* Broadcast Item */
        .broadcast-item {
            padding: 12px 14px;
            border-bottom: 1px solid var(--border);
            background: rgba(163, 113, 247, 0.05);
        }
        
        .broadcast-item:last-child { border-bottom: none; }
        
        .broadcast-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        
        .broadcast-task {
            font-weight: 500;
            color: var(--accent-purple);
            font-size: 0.9rem;
        }
        
        .broadcast-meta {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }
        
        .agents-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 8px;
        }
        
        .agent-chip {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-family: 'IBM Plex Mono', monospace;
            background: rgba(88, 166, 255, 0.15);
            color: var(--accent-blue);
        }
        
        .timer-display {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.85rem;
            padding: 2px 8px;
            border-radius: 4px;
            background: rgba(210, 153, 34, 0.2);
            color: var(--accent-orange);
        }
        
        .radius-badge {
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(163, 113, 247, 0.2);
            color: var(--accent-purple);
        }
        
        /* Blocked Task Item */
        .blocked-item {
            padding: 10px 14px;
            border-bottom: 1px solid var(--border);
        }
        
        .blocked-item:last-child { border-bottom: none; }
        
        .blocked-reason {
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(248, 81, 73, 0.15);
            color: var(--accent-red);
            margin-top: 4px;
            display: inline-block;
        }
        
        /* Log */
        .log-entry {
            padding: 6px 14px;
            border-bottom: 1px solid var(--border);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.75rem;
            display: flex;
            gap: 10px;
        }
        
        .log-entry:last-child { border-bottom: none; }
        .log-time { color: var(--text-secondary); flex-shrink: 0; }
        .log-message { word-break: break-word; }
        
        .log-entry.broadcast .log-message { color: var(--accent-purple); }
        .log-entry.success .log-message { color: var(--accent-green); }
        .log-entry.warning .log-message { color: var(--accent-orange); }
        .log-entry.error .log-message { color: var(--accent-red); }
        .log-entry.info .log-message { color: var(--accent-cyan); }
        
        /* Config Panel */
        .config-panel {
            margin-top: 16px;
        }
        
        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 12px;
            padding: 14px;
        }
        
        .config-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .config-item label {
            font-size: 0.7rem;
            color: var(--text-secondary);
        }
        
        .config-item input, .config-item select {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 8px 10px;
            color: var(--text-primary);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.8rem;
        }
        
        .config-item input:focus, .config-item select:focus {
            outline: none;
            border-color: var(--accent-blue);
        }
        
        .btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            font-size: 0.75rem;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        
        .btn:hover { opacity: 0.8; }
        .btn-primary { background: var(--accent-blue); color: white; }
        .btn-secondary { background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border); }
        
        .empty-state {
            padding: 30px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        .section-divider {
            grid-column: 1 / -1;
            padding: 10px 0;
            border-top: 1px solid var(--border);
            margin-top: 8px;
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-secondary);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üì° Proximity Broadcast Debug</h1>
        <div style="display: flex; gap: 12px; align-items: center;">
            <span class="status-badge" id="modeBadge">LOADING</span>
            <span class="status-badge" id="connectionBadge">Connecting...</span>
        </div>
    </div>
    
    <div class="stats-grid">
        <div class="stat-card cyan">
            <div class="value" id="onlineAgents">0</div>
            <div class="label">Online Agents</div>
        </div>
        <div class="stat-card orange">
            <div class="value" id="unassignedTasks">0</div>
            <div class="label">Unassigned Tasks</div>
        </div>
        <div class="stat-card purple">
            <div class="value" id="activeBroadcasts">0</div>
            <div class="label">Broadcasting</div>
        </div>
        <div class="stat-card green">
            <div class="value" id="feasibleAgents">0</div>
            <div class="label">Feasible Agents</div>
        </div>
        <div class="stat-card red">
            <div class="value" id="blockedTasks">0</div>
            <div class="label">Blocked Tasks</div>
        </div>
        <div class="stat-card blue">
            <div class="value" id="timeout">120</div>
            <div class="label">Timeout (s)</div>
        </div>
    </div>
    
    <!-- Row 1: Agents and Unassigned Tasks -->
    <div class="main-grid">
        <div class="panel">
            <div class="panel-header">
                <h2>üë• Online Agents</h2>
                <span id="agentCount" style="color: var(--text-secondary); font-size: 0.75rem;"></span>
            </div>
            <div class="panel-content" id="agentList">
                <div class="empty-state">Loading agents...</div>
            </div>
        </div>
        
        <div class="panel">
            <div class="panel-header">
                <h2>üìã Unassigned Tasks</h2>
                <span id="taskCount" style="color: var(--text-secondary); font-size: 0.75rem;"></span>
            </div>
            <div class="panel-content" id="taskList">
                <div class="empty-state">Loading tasks...</div>
            </div>
        </div>
    </div>
    
    <!-- Row 2: Active Broadcasts and Blocked Tasks -->
    <div class="main-grid" style="margin-top: 16px;">
        <div class="panel">
            <div class="panel-header">
                <h2>üì° Active Broadcasts</h2>
                <span id="broadcastCount" style="color: var(--text-secondary); font-size: 0.75rem;"></span>
            </div>
            <div class="panel-content tall" id="broadcastList">
                <div class="empty-state">No active broadcasts</div>
            </div>
        </div>
        
        <div class="panel">
            <div class="panel-header">
                <h2>üö´ Blocked Tasks</h2>
                <span style="color: var(--text-secondary); font-size: 0.75rem;">No eligible agents</span>
            </div>
            <div class="panel-content" id="blockedList">
                <div class="empty-state">No blocked tasks</div>
            </div>
        </div>
    </div>
    
    <!-- Row 3: Event Log -->
    <div class="panel" style="margin-top: 16px;">
        <div class="panel-header">
            <h2>üìù Event Log</h2>
            <button class="btn btn-secondary" onclick="clearLog()">Clear</button>
        </div>
        <div class="panel-content" id="logContent" style="max-height: 200px;">
            <div class="log-entry">
                <span class="log-time">--:--:--</span>
                <span class="log-message">Connecting to server...</span>
            </div>
        </div>
    </div>
    
    <!-- Settings Panel -->
    <div class="panel config-panel">
        <div class="panel-header">
            <h2>‚öôÔ∏è Proximity Broadcast Settings</h2>
        </div>
        <div class="config-grid">
            <div class="config-item">
                <label>Mode</label>
                <select id="modeSelect">
                    <option value="true">Broadcast (Multi-Agent)</option>
                    <option value="false">Auto-Assign (Single Agent)</option>
                </select>
            </div>
            <div class="config-item">
                <label>Task Timeout (seconds)</label>
                <input type="number" id="timeoutInput" value="120" min="30" max="600" step="10">
            </div>
            <div class="config-item">
                <label>Default Radius (km)</label>
                <input type="number" id="radiusInput" value="3.0" min="0.5" max="10" step="0.5">
            </div>
            <div class="config-item" style="justify-content: flex-end;">
                <button class="btn btn-primary" onclick="applySettings()">Apply Settings</button>
            </div>
        </div>
    </div>
    
    <script>
        const socket = io(window.location.origin, { transports: ['websocket', 'polling'] });
        
        // State
        let agents = [];
        let tasks = [];
        let proximityTriggers = [];
        let activeBroadcasts = new Map();
        let declinedTasks = new Map();  // Tasks blocked due to decline (Tookan won't push)
        let waitingForAgents = new Map();  // Tasks that tried to broadcast but found no agents
        let logEntries = [];
        const MAX_LOG = 30;
        
        // Settings
        let broadcastEnabled = true;
        let taskTimeout = 120;
        let defaultRadius = 3.0;
        
        // Fetch initial data
        async function fetchData() {
            try {
                const [agentsRes, tasksRes, proximityRes, configRes] = await Promise.all([
                    fetch('/fleet-state/agents'),
                    fetch('/fleet-state/tasks'),
                    fetch('/fleet-state/proximity'),
                    fetch('/fleet-state/config')
                ]);
                
                agents = (await agentsRes.json()).agents || [];
                const tasksData = await tasksRes.json();
                tasks = tasksData.tasks || tasksData.unassigned_tasks || [];
                const proximityData = await proximityRes.json();
                proximityTriggers = proximityData.triggers || [];
                
                const config = await configRes.json();
                broadcastEnabled = config.proximity_broadcast_enabled ?? true;
                taskTimeout = config.proximity_task_timeout_seconds || 120;
                defaultRadius = config.proximity_default_radius_km || 3.0;
                
                updateAllUI();
            } catch (e) {
                console.error('Fetch error:', e);
            }
        }
        
        socket.on('connect', () => {
            document.getElementById('connectionBadge').textContent = 'Connected';
            document.getElementById('connectionBadge').className = 'status-badge connected';
            addLog('system', 'Connected to OR-Tools server');
            fetchData();
        });
        
        socket.on('disconnect', () => {
            document.getElementById('connectionBadge').textContent = 'Disconnected';
            document.getElementById('connectionBadge').className = 'status-badge disconnected';
            addLog('error', 'Disconnected from server');
        });
        
        // Listen for fleet updates (includes task assignments from fleet optimizer)
        socket.on('fleet:routes_updated', (data) => {
            // Check if any tasks were assigned and remove from activeBroadcasts
            if (data && data.agent_routes) {
                data.agent_routes.forEach(route => {
                    const assignedTasks = route.assigned_new_tasks || [];
                    assignedTasks.forEach(taskId => {
                        if (activeBroadcasts.has(taskId)) {
                            const broadcast = activeBroadcasts.get(taskId);
                            activeBroadcasts.delete(taskId);
                            autoTriggeredTasks.delete(taskId);
                            addLog('success', `‚úÖ ${broadcast.task_name} ‚Üí ${route.driver_name} (fleet optimizer)`);
                        }
                        waitingForAgents.delete(taskId);
                        declinedTasks.delete(taskId);
                    });
                });
            }
            fetchData();
        });
        
        // Track which tasks have been auto-triggered (declared here so it's accessible)
        const autoTriggeredTasks = new Set();
        
        // New task created - refresh data
        socket.on('task:created', (data) => {
            addLog('system', `üìã New task: ${data.restaurant_name} ${data.is_premium ? '‚≠ê' : ''}`);
            fetchData();  // Refresh to get updated task list
        });
        
        // Listen for proximity broadcasts
        socket.on('task:proximity', (data) => {
            const task = data.task || {};
            const feasibleAgents = data.feasible_agents || [];
            
            // Clear auto-triggered flag so task can timeout again if needed
            autoTriggeredTasks.delete(task.id);
            
            // Only add to activeBroadcasts if there are agents to broadcast to
            if (feasibleAgents.length > 0) {
                activeBroadcasts.set(task.id, {
                    task_id: task.id,
                    task_name: task.restaurant_name,
                    customer: task.customer_name,
                    pickup_before: task.times?.pickup_before,
                    delivery_before: task.times?.delivery_before,
                    payment: task.payment?.total || 0,
                    is_premium: task.is_premium,
                    agents: feasibleAgents,
                    competition: data.competition || feasibleAgents.length,
                    first_offered_at: data.first_offered_at,
                    timeout_seconds: data.timeout_seconds || taskTimeout,
                    search_radius_km: data.search_radius_km || defaultRadius,
                    triggered_by: data.triggered_by,
                    timestamp: data.timestamp
                });
                // Remove from waiting since agents found
                waitingForAgents.delete(task.id);
                addLog('broadcast', `üì° ${task.restaurant_name} ‚Üí ${feasibleAgents.length} agents (radius: ${data.search_radius_km}km)`);
            } else {
                // No agents found - remove from active broadcasts and track as waiting
                activeBroadcasts.delete(task.id);
                waitingForAgents.set(task.id, {
                    task_id: task.id,
                    task_name: task.restaurant_name,
                    search_radius_km: data.search_radius_km || defaultRadius,
                    last_checked: Date.now(),
                    triggered_by: data.triggered_by
                });
                addLog('warning', `‚è≥ ${task.restaurant_name} - no agents in ${data.search_radius_km}km radius, waiting...`);
            }
            
            fetchData(); // Refresh to get updated proximity triggers
        });
        
        // Task assigned - remove from active broadcasts
        socket.on('task:assigned', (data) => {
            const taskId = data.id || data.task_id;
            console.log('[DEBUG] task:assigned received:', taskId, 'activeBroadcasts has:', activeBroadcasts.has(taskId));
            
            if (activeBroadcasts.has(taskId)) {
                const broadcast = activeBroadcasts.get(taskId);
                activeBroadcasts.delete(taskId);
                autoTriggeredTasks.delete(taskId);
                addLog('success', `‚úÖ ${broadcast.task_name} ‚Üí ${data.agent_name} (assigned)`);
            } else {
                // Task wasn't in activeBroadcasts but still log it
                addLog('success', `‚úÖ ${data.task_name || taskId?.substring(0, 15) + '...'} ‚Üí ${data.agent_name} (assigned)`);
            }
            waitingForAgents.delete(taskId);  // Clear from waiting
            declinedTasks.delete(taskId);  // Clear from declined if manually assigned
            updateAllUI();  // Immediately update UI
            fetchData();    // Then refresh data
        });
        
        // Pickup completed - agent picked up food, now delivering
        socket.on('pickup:completed', (data) => {
            const restaurant = data.restaurant_name || 'Unknown';
            addLog('info', `üì¶ Pickup: ${restaurant} by ${data.agent_name} (now delivering)`);
            // Don't remove from tracking - task still in progress
        });
        
        // Task (delivery) completed - refresh data (task no longer in unassigned list)
        socket.on('task:completed', (data) => {
            // Task is fully done - remove from all tracking
            activeBroadcasts.delete(data.id);
            autoTriggeredTasks.delete(data.id);
            waitingForAgents.delete(data.id);
            declinedTasks.delete(data.id);
            addLog('success', `üèÅ Delivery completed by ${data.agent_name}`);
            fetchData();  // Refresh to get updated task list
        });
        
        // Task cancelled - remove from all tracking
        socket.on('task:cancelled', (data) => {
            activeBroadcasts.delete(data.id);
            autoTriggeredTasks.delete(data.id);
            waitingForAgents.delete(data.id);
            declinedTasks.delete(data.id);
            addLog('warning', `‚ùå Task cancelled: ${data.reason || 'unknown reason'}`);
            fetchData();  // Refresh to get updated task list
        });
        
        // Task accepted - remove from active broadcasts (proximity mode)
        socket.on('task:accepted', (data) => {
            const taskId = data.id || data.task_id;
            if (activeBroadcasts.has(taskId)) {
                const broadcast = activeBroadcasts.get(taskId);
                activeBroadcasts.delete(taskId);
                autoTriggeredTasks.delete(taskId);
                addLog('success', `‚úÖ ${broadcast.task_name} ‚Üí ${data.agent_name} (accepted)`);
            }
            waitingForAgents.delete(taskId);  // Clear from waiting
            declinedTasks.delete(taskId);  // Also clear from declined if somehow there
            fetchData();
        });
        
        // Task blocked (declined - Tookan won't push notifications)
        socket.on('task:blocked', (data) => {
            const taskId = data.task_id;
            declinedTasks.set(taskId, {
                task_id: taskId,
                restaurant_name: data.restaurant_name,
                reason: data.reason,
                details: data.details,
                declined_by: data.declined_by || [],
                timestamp: data.timestamp
            });
            
            // Remove from active broadcasts if it was there
            if (activeBroadcasts.has(taskId)) {
                activeBroadcasts.delete(taskId);
                autoTriggeredTasks.delete(taskId);
            }
            
            addLog('error', `‚õî ${data.restaurant_name} BLOCKED - ${data.details}`);
            updateAllUI();
        });
        
        // Settings updated via config:update_ack
        socket.on('config:update_ack', (data) => {
            if (data.success && data.config_applied) {
                broadcastEnabled = data.config_applied.proximity_broadcast_enabled ?? broadcastEnabled;
                taskTimeout = data.config_applied.proximity_task_timeout_seconds ?? taskTimeout;
                defaultRadius = data.config_applied.proximity_default_radius_km ?? defaultRadius;
                updateSettingsUI();
                addLog('success', `‚úÖ Settings updated: mode=${broadcastEnabled ? 'BROADCAST' : 'AUTO'}, timeout=${taskTimeout}s, radius=${defaultRadius}km`);
            } else if (!data.success) {
                addLog('error', `‚ùå Settings update failed: ${data.error}`);
            }
        });
        
        // Timeout/expand results
        socket.on('proximity:timeout_result', (data) => {
            if (data.success) {
                addLog('warning', `‚è∞ Task timeout - re-broadcast to ${data.broadcast_count} agents`);
            } else {
                addLog('error', `‚è∞ Timeout failed: ${data.error}`);
            }
        });
        
        socket.on('proximity:expand_result', (data) => {
            if (data.success) {
                addLog('broadcast', `üìè Radius expanded to ${data.new_radius_km}km - ${data.broadcast_count} agents`);
            } else {
                addLog('error', `üìè Expand failed: ${data.error}`);
            }
        });
        
        function updateAllUI() {
            updateStatsUI();
            updateAgentsUI();
            updateTasksUI();
            updateBroadcastsUI();
            updateBlockedUI();
            updateSettingsUI();
        }
        
        function updateStatsUI() {
            document.getElementById('onlineAgents').textContent = agents.length;
            document.getElementById('unassignedTasks').textContent = tasks.length;
            document.getElementById('activeBroadcasts').textContent = activeBroadcasts.size;
            
            let totalFeasible = 0;
            activeBroadcasts.forEach(b => totalFeasible += b.agents.length);
            document.getElementById('feasibleAgents').textContent = totalFeasible;
            
            // Blocked/Waiting breakdown:
            // - Tasks in waitingForAgents = no agents nearby
            // - Tasks in declinedTasks = blocked due to decline
            // - Tasks not in any category = awaiting first proximity trigger
            const broadcastingTaskIds = new Set(activeBroadcasts.keys());
            const waitingCount = waitingForAgents.size;
            const declinedCount = declinedTasks.size;
            const awaitingTrigger = tasks.filter(t => 
                !broadcastingTaskIds.has(t.id) && 
                !waitingForAgents.has(t.id) && 
                !declinedTasks.has(t.id)
            ).length;
            
            const totalBlocked = waitingCount + declinedCount + awaitingTrigger;
            document.getElementById('blockedTasks').textContent = totalBlocked;
            
            // Update blocked label to show breakdown
            const blockedLabel = document.querySelector('#blockedTasks').parentElement;
            if (blockedLabel) {
                const parts = [];
                if (waitingCount > 0) parts.push(`${waitingCount} no agents`);
                if (declinedCount > 0) parts.push(`${declinedCount} declined`);
                if (awaitingTrigger > 0) parts.push(`${awaitingTrigger} awaiting trigger`);
                blockedLabel.title = parts.join(', ') || 'None blocked';
            }
            
            document.getElementById('timeout').textContent = taskTimeout;
        }
        
        function updateAgentsUI() {
            const list = document.getElementById('agentList');
            document.getElementById('agentCount').textContent = `${agents.length} total`;
            
            if (agents.length === 0) {
                list.innerHTML = '<div class="empty-state">No agents online</div>';
                return;
            }
            
            // Sort: idle first, then busy, then at capacity
            const sorted = [...agents].sort((a, b) => {
                const statusOrder = { 'idle': 0, 'busy': 1, 'at_capacity': 2 };
                const aStatus = a.current_tasks >= a.max_capacity ? 'at_capacity' : (a.current_tasks > 0 ? 'busy' : 'idle');
                const bStatus = b.current_tasks >= b.max_capacity ? 'at_capacity' : (b.current_tasks > 0 ? 'busy' : 'idle');
                return (statusOrder[aStatus] || 2) - (statusOrder[bStatus] || 2);
            });
            
            list.innerHTML = sorted.map(a => {
                const taskCount = a.current_tasks || 0;
                const maxCap = a.max_capacity || 2;
                const status = taskCount >= maxCap ? 'at-capacity' : (taskCount > 0 ? 'busy' : 'idle');
                const statusLabel = status === 'at-capacity' ? 'AT_CAPACITY' : status.toUpperCase();
                const lat = a.current_location?.lat || 0;
                const lng = a.current_location?.lng || 0;
                
                return `
                    <div class="agent-item">
                        <div class="agent-info">
                            <div class="agent-name">${a.name}</div>
                            <div class="agent-details">
                                ID: ${a.id} | Tasks: ${taskCount}/${maxCap} | Loc: [${lat.toFixed(4)}, ${lng.toFixed(4)}]
                            </div>
                        </div>
                        <span class="agent-status ${status}">${statusLabel}</span>
                    </div>
                `;
            }).join('');
        }
        
        function updateTasksUI() {
            const list = document.getElementById('taskList');
            document.getElementById('taskCount').textContent = `${tasks.length} unassigned`;
            
            if (tasks.length === 0) {
                list.innerHTML = '<div class="empty-state">No unassigned tasks</div>';
                return;
            }
            
            // Sort by urgency
            const sorted = [...tasks].sort((a, b) => (b.urgency_score || 0) - (a.urgency_score || 0));
            
            list.innerHTML = sorted.map(t => {
                const isBroadcasting = activeBroadcasts.has(t.id);
                const broadcast = activeBroadcasts.get(t.id);
                const isWaitingForAgents = waitingForAgents.has(t.id);
                const waitingInfo = waitingForAgents.get(t.id);
                const isDeclined = declinedTasks.has(t.id);
                const urgency = t.urgency_score || 0;
                const isPremium = t.is_premium || (t.tips && t.tips > 0);
                const pickupTime = t.pickup_before ? new Date(t.pickup_before).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '?';
                
                let badge = '';
                if (isBroadcasting) {
                    badge = `<span class="task-badge broadcasting">üì° ${broadcast.agents.length} AGENTS</span>`;
                } else if (isDeclined) {
                    badge = '<span class="task-badge declined">‚õî DECLINED</span>';
                } else if (isWaitingForAgents) {
                    badge = `<span class="task-badge no-agents">‚è≥ NO AGENTS (${waitingInfo.search_radius_km}km)</span>`;
                } else if (urgency >= 70) {
                    badge = '<span class="task-badge urgent">URGENT</span>';
                } else if (isPremium) {
                    badge = '<span class="task-badge premium">‚≠ê PREMIUM</span>';
                } else {
                    badge = '<span class="task-badge waiting">WAITING</span>';
                }
                
                return `
                    <div class="task-item">
                        <div class="task-header">
                            <span class="task-name">${t.restaurant_name} ‚Üí ${t.customer_name}</span>
                            ${badge}
                        </div>
                        <div class="task-details">
                            Urgency: ${urgency} | Pickup: ${pickupTime} | $${((t.delivery_fee || 0) + (t.tips || 0)).toFixed(2)}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function updateBroadcastsUI() {
            const list = document.getElementById('broadcastList');
            document.getElementById('broadcastCount').textContent = activeBroadcasts.size > 0 
                ? `${activeBroadcasts.size} active` : '';
            
            if (activeBroadcasts.size === 0) {
                list.innerHTML = '<div class="empty-state">No active broadcasts - waiting for proximity triggers</div>';
                return;
            }
            
            const now = Date.now() / 1000;
            
            list.innerHTML = Array.from(activeBroadcasts.values()).map(b => {
                const elapsed = now - b.first_offered_at;
                const remaining = Math.max(0, b.timeout_seconds - elapsed);
                
                return `
                    <div class="broadcast-item">
                        <div class="broadcast-header">
                            <span class="broadcast-task">${b.task_name} ‚Üí ${b.customer}</span>
                            <span class="timer-display">${Math.floor(remaining)}s</span>
                        </div>
                        <div class="broadcast-meta">
                            ${b.is_premium ? '‚≠ê PREMIUM | ' : ''}
                            $${b.payment.toFixed(2)} | 
                            <span class="radius-badge">${b.search_radius_km}km</span> |
                            Triggered by: ${b.triggered_by}
                        </div>
                        <div class="agents-list">
                            ${b.agents.map(a => `
                                <span class="agent-chip">${a.agent_name} (${a.distance_km}km)</span>
                            `).join('')}
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button class="btn btn-secondary" onclick="triggerTimeout('${b.task_id}')">Timeout</button>
                            <button class="btn btn-secondary" onclick="expandRadius('${b.task_id}', ${b.search_radius_km + 2})">Expand +2km</button>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function updateBlockedUI() {
            const list = document.getElementById('blockedList');
            const broadcastingTaskIds = new Set(activeBroadcasts.keys());
            const blocked = tasks.filter(t => !broadcastingTaskIds.has(t.id));
            
            if (blocked.length === 0 && declinedTasks.size === 0) {
                list.innerHTML = '<div class="empty-state">All tasks are broadcasting or have eligible agents</div>';
                return;
            }
            
            // Build reasons from proximity triggers
            const taskReasons = {};
            proximityTriggers.forEach(trigger => {
                if (!trigger.is_eligible && trigger.eligibility_reason) {
                    if (!taskReasons[trigger.task_id]) {
                        taskReasons[trigger.task_id] = new Set();
                    }
                    taskReasons[trigger.task_id].add(trigger.eligibility_reason);
                }
            });
            
            let html = '';
            
            // First show DECLINED tasks (permanent blocks - need manual assignment)
            declinedTasks.forEach((declined, taskId) => {
                const declinedByStr = declined.declined_by.length > 0 
                    ? `Declined by: ${declined.declined_by.length} agent(s)` 
                    : '';
                html += `
                    <div class="blocked-item" style="border-left: 3px solid #ef4444; background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(239, 68, 68, 0.05) 100%);">
                        <div class="task-header">
                            <span class="task-name">${declined.restaurant_name}</span>
                            <span style="background: #ef4444; color: white; padding: 2px 8px; border-radius: 4px; font-size: 10px; font-weight: bold;">‚õî DECLINED</span>
                        </div>
                        <div class="task-details">
                            ${declinedByStr} | Needs manual assignment
                        </div>
                        <span class="blocked-reason" style="color: #ef4444;">Tookan won't push notifications to declined tasks</span>
                    </div>
                `;
            });
            
            // Then show other blocked tasks (might become eligible)
            blocked.forEach(t => {
                // Skip if already shown in declined section
                if (declinedTasks.has(t.id)) return;
                
                // Check if task has declined_by data (was declined before page loaded)
                const hasDeclines = t.declined_by && t.declined_by.length > 0;
                
                if (hasDeclines) {
                    // Show as declined task - needs manual assignment
                    html += `
                        <div class="blocked-item" style="border-left: 3px solid #ef4444; background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(239, 68, 68, 0.05) 100%);">
                            <div class="task-header">
                                <span class="task-name">${t.restaurant_name} ‚Üí ${t.customer_name}</span>
                                <span style="background: #ef4444; color: white; padding: 2px 8px; border-radius: 4px; font-size: 10px; font-weight: bold;">‚õî DECLINED</span>
                            </div>
                            <div class="task-details">
                                $${((t.delivery_fee || 0) + (t.tips || 0)).toFixed(2)} | ${t.is_premium ? '‚≠ê PREMIUM' : 'Regular'} | Declined by ${t.declined_by.length} agent(s)
                            </div>
                            <span class="blocked-reason" style="color: #ef4444;">Tookan won't push notifications - needs manual assignment</span>
                        </div>
                    `;
                } else {
                    // Regular blocked task - no declines, just no eligible agents
                    const reasons = taskReasons[t.id] ? Array.from(taskReasons[t.id]) : ['No agents within radius'];
                    const reasonDisplay = reasons.slice(0, 3).join(', ');
                    
                    html += `
                        <div class="blocked-item">
                            <div class="task-header">
                                <span class="task-name">${t.restaurant_name} ‚Üí ${t.customer_name}</span>
                            </div>
                            <div class="task-details">
                                $${((t.delivery_fee || 0) + (t.tips || 0)).toFixed(2)} | ${t.is_premium ? '‚≠ê PREMIUM' : 'Regular'}
                            </div>
                            <span class="blocked-reason">${reasonDisplay}</span>
                        </div>
                    `;
                }
            });
            
            list.innerHTML = html || '<div class="empty-state">All tasks are broadcasting or have eligible agents</div>';
        }
        
        function updateSettingsUI() {
            document.getElementById('modeBadge').textContent = broadcastEnabled ? 'BROADCAST' : 'AUTO-ASSIGN';
            document.getElementById('modeBadge').className = 'status-badge ' + (broadcastEnabled ? 'enabled' : 'disabled');
            document.getElementById('modeSelect').value = broadcastEnabled.toString();
            document.getElementById('timeoutInput').value = taskTimeout;
            document.getElementById('radiusInput').value = defaultRadius;
        }
        
        function applySettings() {
            // Use existing config:update event
            socket.emit('config:update', {
                config: {
                    proximity_broadcast_enabled: document.getElementById('modeSelect').value === 'true',
                    proximity_task_timeout_seconds: parseInt(document.getElementById('timeoutInput').value),
                    proximity_default_radius_km: parseFloat(document.getElementById('radiusInput').value)
                },
                dashboard_url: window.location.origin
            });
            addLog('system', 'Sending settings update...');
        }
        
        function triggerTimeout(taskId) {
            socket.emit('proximity:timeout', {
                task_id: taskId,
                dashboard_url: window.location.origin
            });
        }
        
        function expandRadius(taskId, newRadius) {
            socket.emit('proximity:expand_radius', {
                task_id: taskId,
                new_radius_km: newRadius,
                dashboard_url: window.location.origin
            });
        }
        
        function addLog(type, message) {
            const time = new Date().toLocaleTimeString();
            logEntries.unshift({ time, type, message });
            if (logEntries.length > MAX_LOG) logEntries = logEntries.slice(0, MAX_LOG);
            renderLog();
        }
        
        function renderLog() {
            const content = document.getElementById('logContent');
            content.innerHTML = logEntries.map(e => `
                <div class="log-entry ${e.type}">
                    <span class="log-time">${e.time}</span>
                    <span class="log-message">${e.message}</span>
                </div>
            `).join('');
        }
        
        function clearLog() {
            logEntries = [];
            renderLog();
        }
        
        // Update timers and AUTO-TRIGGER timeout when timer reaches 0
        setInterval(() => {
            const now = Date.now() / 1000;
            
            // Check for tasks that hit 0s and need auto-trigger
            activeBroadcasts.forEach((b, taskId) => {
                const elapsed = now - b.first_offered_at;
                const remaining = b.timeout_seconds - elapsed;
                
                // If timer hit 0 and we haven't already triggered for this task
                if (remaining <= 0 && !autoTriggeredTasks.has(taskId)) {
                    autoTriggeredTasks.add(taskId);
                    addLog('warning', `‚è∞ Auto-triggering timeout for ${b.task_name}`);
                    
                    // Emit timeout event to re-run solver
                    socket.emit('proximity:timeout', {
                        task_id: taskId,
                        dashboard_url: window.location.origin
                    });
                }
            });
            
            // Clean up triggered tasks that are no longer in active broadcasts
            autoTriggeredTasks.forEach(taskId => {
                if (!activeBroadcasts.has(taskId)) {
                    autoTriggeredTasks.delete(taskId);
                }
            });
            
            updateBroadcastsUI();
            updateStatsUI();
        }, 1000);
        
        // Refresh fleet data every 10 seconds
        setInterval(fetchData, 10000);
        
        // Initial load
        updateSettingsUI();
    </script>
</body>
</html>
